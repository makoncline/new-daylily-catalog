# T3 Stack Principles

- Follow T3 Stack's focus on simplicity, modularity, and full-stack typesafety
- Solve specific problems - don't add unnecessary dependencies
- Typesafety is not optional - ensure end-to-end type safety
- Use bleeding edge tech responsibly - stick to proven solutions for critical infrastructure

# Tech Stack

- Frontend: Next.js, Tailwind, shadcn/ui
- Backend: SQLite, Prisma, tRPC
- Auth: Clerk
- Payments: Stripe
- Deployment: Vercel

# Project Structure

- src/
  - app/ - Next.js app router
    - api/trpc/[trpc] - tRPC HTTP handler
    - (routes) - App routes
    - \_components - Route-specific components
  - components/ - Shared components
    - ui/ - shadcn/ui components
    - forms/ - Form components
  - server/ - Server-side code
    - api/ - tRPC API
      - routers/ - tRPC routers (main business logic)
      - trpc.ts - tRPC initialization
    - db/ - Database utilities
  - lib/ - Shared utilities
    - hooks/ - Custom hooks
    - utils/ - Utility functions
  - types/ - Type definitions
    - schemas/ - Shared Zod schemas

# Core Patterns

1. tRPC:

   - Place core business logic in tRPC routers
   - Keep mutations focused and minimal - only update what's needed
   - Use undefined to skip field updates instead of complex logic
   - Share helper functions between related mutations
   - Use protectedProcedure for authenticated routes
   - Use middleware for ownership checks with database user IDs
   - Hide private fields in public queries
   - Handle cache invalidation in mutations
   - Export router types for reuse
   - Export query output types for components
   - Keep router files focused and organized by domain
   - Use proper error handling with TRPCError
   - Add proper ownership checks for all mutations
   - Use descriptive error messages

2. Database:

   - Use Prisma with SQLite
   - Always include createdAt/updatedAt
   - Use proper indexes and relations
   - Follow Prisma's SQLite best practices
   - Store Clerk user IDs but use database user IDs for relations

3. Forms:

   - Use shadcn/ui form components
   - Use useZodForm from @/lib/hooks for form state management
   - Share Zod schemas between forms and tRPC
   - Handle loading states with isPending state
   - Use toast notifications for success/error feedback
   - Handle null values with transformNullToUndefined utility
   - Use proper type inference with z.infer
   - Add proper form field descriptions and error messages
   - Handle numeric inputs with proper onChange handlers

4. Auth:

   - Use Clerk for authentication
   - Use protectedProcedure for authenticated routes
   - Import currentUser from "@clerk/nextjs/server"
   - Use currentUser() in server, useUser() in client
   - Always get database user via clerkUserId in protected routes
   - Use database user ID (not Clerk ID) for all ownership checks
   - Handle missing database users with proper error messages

5. Schema Organization:
   - Place Zod schemas in src/types/schemas
   - Share schemas between forms and tRPC
   - Use z.infer for type inference
   - Export inferred types for reuse
   - Handle nullable fields with .nullable() and optional()
   - Use proper validation rules
   - Transform null to undefined for form defaultValues
   - Export utility functions for schema transformations
   - Keep schemas focused and minimal
   - Use descriptive validation messages

# Example Patterns

1. Focused tRPC Router:

```typescript
// src/server/api/routers/listing.ts
export const listingRouter = createTRPCRouter({
  update: protectedProcedure
    .input(
      z.object({
        id: z.string(),
        data: listingFormSchema,
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const listing = await ctx.db.listing.findUnique({
        where: { id: input.id },
      });

      if (!listing) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Listing not found",
        });
      }

      const updatedListing = await ctx.db.listing.update({
        where: { id: input.id },
        data: input.data,
        include: {
          ahsListing: true,
          images: {
            orderBy: { order: "asc" },
          },
        },
      });

      revalidatePath("/listings");
      return updatedListing;
    }),
});
```

2. Shared Helper Function:

```typescript
// src/server/api/routers/listing.ts
async function checkListingOwnership(userId: string, listingId: string) {
  const listing = await db.listing.findUnique({
    where: { id: listingId },
  });

  if (!listing) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: "Listing not found",
    });
  }

  if (listing.userId !== userId) {
    throw new TRPCError({
      code: "FORBIDDEN",
      message: "Not authorized",
    });
  }

  return listing;
}
```

3. Form and Schema Example:

```typescript
// src/types/schemas/listing.ts
export const listingFormSchema = z.object({
  name: z.string().min(1, "Name is required").optional(),
  price: z.number().min(0).optional().nullable(),
  publicNote: z.string().optional().nullable(),
});

export type ListingFormData = z.infer<typeof listingFormSchema>;

// src/components/forms/listing-form.tsx
export function ListingForm({ listing }: { listing: ListingGetOutput }) {
  const [isPending, setIsPending] = useState(false);
  const { toast } = useToast();

  const form = useZodForm({
    schema: listingFormSchema,
    defaultValues: {
      ...transformNullToUndefined(listingFormSchema.parse(listing)),
    },
  });

  const { mutateAsync: updateListingMutation } = api.listing.update.useMutation({
    onSuccess: () => {
      toast({ title: "Changes saved" });
    },
    onError: () => {
      toast({ title: "Failed to save changes", variant: "destructive" });
    },
  });

  async function onSubmit(values: ListingFormData) {
    setIsPending(true);
    try {
      await updateListingMutation({
        id: listing.id,
        data: values,
      });
    } finally {
      setIsPending(false);
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  );
}
```

# General Rules

- Use @/ imports
- Use kebab-case for files/folders
- Validate env vars with @t3-oss/env-nextjs
- Don't modify shadcn/ui components
- Follow security best practices
- Handle cache invalidation consistently
- Hide private fields in public queries
- Use middleware for common checks
- Use proper TypeScript types
- Always use database user IDs for ownership checks
- Handle missing users gracefully with proper error messages
- Keep mutations focused and minimal
- Share helper functions between related mutations

````

```;

````
