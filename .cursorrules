# T3 Stack Principles

- Follow T3 Stack's focus on simplicity, modularity, and full-stack typesafety
- Solve specific problems - don't add unnecessary dependencies
- Typesafety is not optional - ensure end-to-end type safety
- Use bleeding edge tech responsibly - stick to proven solutions for critical infrastructure

# Tech Stack

- Frontend: Next.js, Tailwind, shadcn/ui
- Backend: SQLite, Prisma, tRPC
- Auth: Clerk
- Payments: Stripe
- Deployment: Vercel

# Project Structure

- src/
  - app/ - Next.js app router
    - api/trpc/[trpc] - tRPC HTTP handler
    - (routes) - App routes
    - _components - Route-specific components
  - components/ - Shared components
    - ui/ - shadcn/ui components
    - forms/ - Form components
  - server/ - Server-side code
    - api/ - tRPC API
      - routers/ - tRPC routers (main business logic)
      - trpc.ts - tRPC initialization
    - db/ - Database utilities
    - actions/ - Server actions
  - lib/ - Shared utilities
    - hooks/ - Custom hooks
    - utils/ - Utility functions
  - types/ - Type definitions
    - schemas/ - Shared Zod schemas

# Core Patterns

1. tRPC:
   - Place core business logic in tRPC routers
   - Use tRPC mutations for all create/update/delete operations
   - Use tRPC queries for data fetching
   - Handle cache invalidation in tRPC mutations
   - Use protectedProcedure for authenticated routes
   - Use middleware for ownership checks with database user IDs
   - Hide private fields in public queries
   - Share ownership check logic with server actions

2. Database:
   - Use Prisma with SQLite
   - Always include createdAt/updatedAt
   - Use proper indexes and relations
   - Follow Prisma's SQLite best practices
   - Store Clerk user IDs but use database user IDs for relations

3. Forms:
   - Use shadcn/ui form components (Form, FormField, FormItem, FormLabel, FormControl, FormDescription, FormMessage)
   - Use useZodForm from @/lib/hooks for form state management and validation
   - Share Zod schemas between forms and server actions
   - Handle loading states with isPending state
   - Use toast notifications for success/error feedback
   - Use server actions for form submissions
   - Handle null values with transformNullToUndefined utility
   - Use proper type inference with ListingFormData = z.infer<typeof schema>
   - Add proper form field descriptions and error messages
   - Handle numeric inputs with proper onChange handlers

4. Auth:
   - Use Clerk for authentication
   - Use protectedProcedure for authenticated routes
   - Use protectedListingProcedure for owner-only routes
   - Import currentUser from "@clerk/nextjs/server"
   - Use currentUser() in server, useUser() in client
   - Always get database user via clerkUserId in protected routes
   - Use database user ID (not Clerk ID) for all ownership checks
   - Handle missing database users with proper error messages

5. Schema Organization:
   - Place Zod schemas in src/types/schemas
   - Share schemas between forms and server actions
   - Use z.infer for type inference (e.g., ListingFormData)
   - Export inferred types for reuse
   - Handle nullable fields with .nullable() and optional()
   - Use proper validation rules (e.g., min(1) for required fields)
   - Transform null to undefined for form defaultValues
   - Export utility functions for schema transformations
   - Keep schemas focused and minimal
   - Use descriptive validation messages

6. Server Actions:
   - Place server actions in src/server/actions/
   - Use "use server" directive at top of file
   - Get database user via currentUser() and clerkUserId
   - Handle auth and ownership checks consistently
   - Use revalidatePath for cache invalidation
   - Share ownership check logic between actions
   - Prefer server actions over tRPC mutations for form submissions
   - Use the same Zod schemas as tRPC for validation

# Example Patterns

1. Protected Server Action:
```typescript
// src/server/actions/listing.ts
export async function updateListing(listingId: string, data: ListingFormData) {
  const clerkUser = await currentUser();
  if (!clerkUser) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
    });
  }

  const dbUser = await db.user.findUnique({
    where: { clerkUserId: clerkUser.id },
  });

  if (!dbUser) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "User not found in database",
    });
  }

  await checkListingOwnership(dbUser.id, listingId);

  const result = await db.listing.update({
    where: { id: listingId },
    data,
  });

  revalidatePath("/listings");
  return result;
}
```

2. Shared Ownership Check:
```typescript
// src/server/utils/auth.ts
export async function checkListingOwnership(userId: string, listingId: string) {
  const listing = await db.listing.findUnique({
    where: { id: listingId },
  });

  if (!listing) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: "Listing not found",
    });
  }

  if (listing.userId !== userId) {
    throw new TRPCError({
      code: "FORBIDDEN",
      message: "Not authorized",
    });
  }

  return listing;
}
```

3. Form and Schema Example:
```typescript
// src/types/schemas/listing.ts
import { z } from "zod";

export const transformNullToUndefined = <T>(value: T): T | undefined => {
  if (value === null) return undefined;
  if (typeof value === "object" && value !== null) {
    return Object.fromEntries(
      Object.entries(value).map(([key, val]) => [
        key,
        val === null ? undefined : val,
      ]),
    ) as T;
  }
  return value;
};

export const listingFormSchema = z.object({
  name: z.string().min(1, "Name is required"),
  price: z.number().min(0).optional().nullable(),
  publicNote: z.string().optional().nullable(),
});

export type ListingFormData = z.infer<typeof listingFormSchema>;

// src/components/forms/listing-form.tsx
export function ListingForm({ listing }: { listing: ListingGetOutput }) {
  const [isPending, setIsPending] = useState(false);
  const { toast } = useToast();

  const form = useZodForm({
    schema: listingFormSchema,
    defaultValues: {
      ...transformNullToUndefined(listingFormSchema.parse(listing)),
    },
  });

  async function onSubmit(values: ListingFormData) {
    setIsPending(true);
    try {
      await updateListing(listing.id, values);
      toast({ title: "Listing updated successfully" });
    } catch {
      toast({ title: "Failed to update listing", variant: "destructive" });
    } finally {
      setIsPending(false);
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="price"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Price</FormLabel>
              <FormControl>
                <Input
                  type="number"
                  step="0.01"
                  {...field}
                  value={field.value ?? ""}
                  onChange={(e) => {
                    const value = e.target.value;
                    field.onChange(value === "" ? undefined : Number(value));
                  }}
                />
              </FormControl>
              <FormDescription>Optional. Price in dollars.</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={isPending}>
          {isPending ? "Saving..." : "Save Changes"}
        </Button>
      </form>
    </Form>
  );
}
```

# General Rules

- Use @/ imports
- Use kebab-case for files/folders
- Validate env vars with @t3-oss/env-nextjs
- Don't modify shadcn/ui components
- Follow security best practices
- Handle cache invalidation consistently
- Hide private fields in public queries
- Use middleware for common checks
- Use proper TypeScript types
- Always use database user IDs for ownership checks
- Handle missing users gracefully with proper error messages
- Share validation and ownership logic between tRPC and server actions
- Prefer server actions for form submissions

```

```;

