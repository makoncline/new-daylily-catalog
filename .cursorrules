# T3 Stack Principles

- Follow T3 Stack's focus on simplicity, modularity, and full-stack typesafety
- Solve specific problems - don't add unnecessary dependencies
- Typesafety is not optional - ensure end-to-end type safety
- Use bleeding edge tech responsibly - stick to proven solutions for critical infrastructure

# Tech Stack

- Frontend: Next.js, Tailwind, shadcn/ui
- Backend: SQLite, Prisma, tRPC
- Auth: Clerk
- Payments: Stripe
- Deployment: Vercel

# Project Structure

- src/
  - app/ - Next.js app router
    - api/trpc/[trpc] - tRPC HTTP handler
    - (routes) - App routes
    - _components - Route-specific components
  - components/ - Shared components
    - ui/ - shadcn/ui components
    - forms/ - Form components
  - server/ - Server-side code
    - api/ - tRPC API
      - routers/ - tRPC routers (main business logic)
      - trpc.ts - tRPC initialization
    - db/ - Database utilities
    - actions/ - Server actions
  - lib/ - Shared utilities
    - hooks/ - Custom hooks
    - utils/ - Utility functions
  - types/ - Type definitions
    - schemas/ - Shared Zod schemas

# Core Patterns

1. tRPC:
   - Place core business logic in tRPC routers
   - Use tRPC mutations for all create/update/delete operations
   - Use tRPC queries for data fetching
   - Handle cache invalidation in tRPC mutations
   - Use protectedProcedure for authenticated routes
   - Use middleware for ownership checks with database user IDs
   - Hide private fields in public queries
   - Share ownership check logic with server actions

2. Database:
   - Use Prisma with SQLite
   - Always include createdAt/updatedAt
   - Use proper indexes and relations
   - Follow Prisma's SQLite best practices
   - Store Clerk user IDs but use database user IDs for relations

3. Forms:
   - Use shadcn/ui form components
   - Use useZodForm from @/lib/hooks
   - Share Zod schemas between forms and tRPC
   - Handle loading and error states
   - Use server actions for form submissions

4. Auth:
   - Use Clerk for authentication
   - Use protectedProcedure for authenticated routes
   - Use protectedListingProcedure for owner-only routes
   - Import currentUser from "@clerk/nextjs/server"
   - Use currentUser() in server, useUser() in client
   - Always get database user via clerkUserId in protected routes
   - Use database user ID (not Clerk ID) for all ownership checks
   - Handle missing database users with proper error messages

5. Schema Organization:
   - Place Zod schemas in src/types/schemas
   - Share schemas between forms, tRPC, and server actions
   - Use z.infer for type inference
   - Export inferred types
   - Validate data consistently across all entry points

6. Server Actions:
   - Place server actions in src/server/actions/
   - Use "use server" directive at top of file
   - Get database user via currentUser() and clerkUserId
   - Handle auth and ownership checks consistently
   - Use revalidatePath for cache invalidation
   - Share ownership check logic between actions
   - Prefer server actions over tRPC mutations for form submissions
   - Use the same Zod schemas as tRPC for validation

# Example Patterns

1. Protected Server Action:
```typescript
// src/server/actions/listing.ts
export async function updateListing(listingId: string, data: ListingFormData) {
  const clerkUser = await currentUser();
  if (!clerkUser) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
    });
  }

  const dbUser = await db.user.findUnique({
    where: { clerkUserId: clerkUser.id },
  });

  if (!dbUser) {
    throw new TRPCError({
      code: "UNAUTHORIZED",
      message: "User not found in database",
    });
  }

  await checkListingOwnership(dbUser.id, listingId);

  const result = await db.listing.update({
    where: { id: listingId },
    data,
  });

  revalidatePath("/listings");
  return result;
}
```

2. Shared Ownership Check:
```typescript
// src/server/utils/auth.ts
export async function checkListingOwnership(userId: string, listingId: string) {
  const listing = await db.listing.findUnique({
    where: { id: listingId },
  });

  if (!listing) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: "Listing not found",
    });
  }

  if (listing.userId !== userId) {
    throw new TRPCError({
      code: "FORBIDDEN",
      message: "Not authorized",
    });
  }

  return listing;
}
```

# General Rules

- Use @/ imports
- Use kebab-case for files/folders
- Validate env vars with @t3-oss/env-nextjs
- Don't modify shadcn/ui components
- Follow security best practices
- Handle cache invalidation consistently
- Hide private fields in public queries
- Use middleware for common checks
- Use proper TypeScript types
- Always use database user IDs for ownership checks
- Handle missing users gracefully with proper error messages
- Share validation and ownership logic between tRPC and server actions
- Prefer server actions for form submissions

```

```;

