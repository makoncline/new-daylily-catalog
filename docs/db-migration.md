# Database Migration Workflow

This document defines the default, database-agnostic migration workflow for this repo.

## Goals

- Keep schema and data changes predictable.
- Use the same SQL artifacts in local, stage, and production.
- Make every migration rerunnable and auditable.

## Core Model

Use a 3-step migration model:

1. Structural changes: Prisma-generated SQL in `prisma/migrations/...`.
2. Data changes: deterministic SQL files generated by script into `prisma/data-migrations/...`.
3. Apply the same SQL files in the same order in local -> stage -> production.

## Rules

- Structural SQL must come from Prisma schema changes.
- Data SQL should be generated by script, not written manually each run.
- Data SQL must be deterministic and idempotent.
- Validate locally before stage and production.
- Do not use `pnpm env:dev -- ...` (this causes `spawn -- ENOENT`).
- Always run env wrapper commands as `pnpm env:dev <command>`.

## Step 0: Prepare a Local Prod Copy

```bash
pnpm env:dev bash scripts/db-backup.sh
```

Expected local artifact:

```text
prisma/local-prod-copy-daylily-catalog.db
```

## Step 1: Generate Structural Migration SQL

1. Update `prisma/schema.prisma`.
2. Generate migration SQL (create-only):

```bash
NODE_OPTIONS='' RUST_LOG=info npx dotenv -e .env.development -- \
  npx prisma migrate dev --create-only --name <migration_name>
```

If create-only fails on local copy, generate SQL via diff:

```bash
npx prisma migrate diff \
  --from-url file:./prisma/local-prod-copy-daylily-catalog.db \
  --to-schema-datamodel prisma/schema.prisma \
  --script > prisma/migrations/<timestamp>_<migration_name>/migration.sql
```

## Step 2: Generate Data SQL

1. Create/update a generator script in `scripts/`.
2. Generate SQL into `prisma/data-migrations/`.
3. Run the generator command for your migration.

Example pattern:

```bash
pnpm <data-migration-generator-script>
```

## Step 3: Apply Locally

Apply structural SQL first, then data SQL:

```bash
sqlite3 prisma/local-prod-copy-daylily-catalog.db < prisma/migrations/<timestamp>_<migration_name>/migration.sql
sqlite3 prisma/local-prod-copy-daylily-catalog.db < prisma/data-migrations/<first_data_sql>.sql
sqlite3 prisma/local-prod-copy-daylily-catalog.db < prisma/data-migrations/<second_data_sql>.sql
```

## Step 4: Validate Locally

Run migration-specific validation queries and keep results in PR/deploy notes.

Recommended generic checks:

1. Row-count sanity checks for touched tables.
2. Foreign-key/orphan checks for new relationships.
3. Uniqueness checks for new keys/constraints.
4. Spot checks for normalized/transformed columns.

## Step 5: Apply to Stage

Apply the exact same SQL files in the exact same order:

```bash
turso db shell daylily-catalog-stage < prisma/migrations/<timestamp>_<migration_name>/migration.sql
turso db shell daylily-catalog-stage < prisma/data-migrations/<first_data_sql>.sql
turso db shell daylily-catalog-stage < prisma/data-migrations/<second_data_sql>.sql
```

Run the same validation queries in stage. Do not continue until they pass.

## Step 6: Apply to Production

Take a fresh backup immediately before production apply:

```bash
pnpm env:dev bash scripts/db-backup.sh
```

Apply the exact same SQL files in the same order:

```bash
turso db shell daylily-catalog < prisma/migrations/<timestamp>_<migration_name>/migration.sql
turso db shell daylily-catalog < prisma/data-migrations/<first_data_sql>.sql
turso db shell daylily-catalog < prisma/data-migrations/<second_data_sql>.sql
```

## Migration-Specific Runbooks

For migration-specific commands, queries, and acceptance gates, create a dedicated doc in `docs/` and link it from the PR.

Current example:

- `docs/cultivar-reference-migration.md`

## PR Checklist

Each migration PR should include:

- `prisma/schema.prisma` changes.
- Structural migration SQL under `prisma/migrations/`.
- Data SQL generator script under `scripts/`.
- Generated data SQL under `prisma/data-migrations/`.
- Validation notes (local/stage/prod as applicable).
